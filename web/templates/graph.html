{% extends "base.html" %}

{% block title %}EngramDB - Memory Graph{% endblock %}

{% block header %}Memory Network Visualization{% endblock %}

{% block head %}
<!-- D3.js for graph visualization -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<!-- Force Graph library -->
<script src="https://unpkg.com/force-graph"></script>
<style>
    #graph-container {
        width: 100%;
        height: 600px;
        border: 1px solid #ddd;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
    }
    .graph-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 10;
        background-color: rgba(255,255,255,0.9);
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        max-height: 500px;
        overflow-y: auto;
        width: 200px;
        transition: all 0.3s ease;
    }
    .graph-controls:hover {
        background-color: rgba(255,255,255,1);
    }
    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 7px;
        font-size: 0.85rem;
    }
    .legend-color {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        border-radius: 3px;
        border: 1px solid rgba(0,0,0,0.1);
    }
    .graph-controls h6 {
        margin-top: 0;
        margin-bottom: 10px;
        font-weight: 600;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
    }
    .debug-info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        font-size: 12px;
        color: #666;
        background: rgba(255,255,255,0.8);
        padding: 5px;
        border-radius: 4px;
        max-width: 400px;
        z-index: 100;
    }
</style>
{% endblock %}

{% block content %}
<div class="card shadow mb-4">
    <div class="card-header bg-light d-flex justify-content-between align-items-center">
        <h5 class="card-title mb-0">Memory Graph</h5>
        <div class="d-flex align-items-center flex-wrap">
            <div class="form-check form-switch me-3 mb-2">
                <input class="form-check-input" type="checkbox" id="showNodeLabels">
                <label class="form-check-label" for="showNodeLabels">Node Labels</label>
            </div>
            <div class="form-check form-switch me-3 mb-2">
                <input class="form-check-input" type="checkbox" id="showLinkLabels">
                <label class="form-check-label" for="showLinkLabels">Link Labels</label>
            </div>
            <div class="input-group input-group-sm me-3 mb-2" style="width: 200px;">
                <label class="input-group-text" for="layoutAlgorithm">Layout</label>
                <select class="form-select form-select-sm" id="layoutAlgorithm">
                    <option value="d3">D3 Force</option>
                    <option value="forceAtlas2">Force Atlas 2</option>
                    <option value="ngraph">Ngraph (Fast)</option>
                </select>
            </div>
            <div class="btn-group me-3 mb-2">
                <button class="btn btn-sm btn-outline-secondary" id="zoomInBtn" title="Zoom In">
                    <i class="bi bi-zoom-in"></i>
                </button>
                <button class="btn btn-sm btn-outline-secondary" id="zoomOutBtn" title="Zoom Out">
                    <i class="bi bi-zoom-out"></i>
                </button>
                <button class="btn btn-sm btn-outline-secondary" id="resetBtn" title="Reset View">
                    <i class="bi bi-arrow-counterclockwise"></i>
                </button>
            </div>
            <div class="btn-group me-3 mb-2">
                <button class="btn btn-sm btn-outline-primary" id="expandBtn" title="Expand Graph">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <button class="btn btn-sm btn-outline-primary" id="contractBtn" title="Contract Graph">
                    <i class="bi bi-arrows-angle-contract"></i>
                </button>
            </div>
            <div class="dropdown mb-2">
                <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" id="settingsDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                    <i class="bi bi-gear"></i> Settings
                </button>
                <ul class="dropdown-menu" aria-labelledby="settingsDropdown">
                    <li><h6 class="dropdown-header">Debug Options</h6></li>
                    <li>
                        <div class="dropdown-item">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="enableDebug">
                                <label class="form-check-label" for="enableDebug">Enable Debugging</label>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="dropdown-item">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="showDebugOverlay">
                                <label class="form-check-label" for="showDebugOverlay">Show Debug Overlay</label>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="dropdown-item">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="showEventLog">
                                <label class="form-check-label" for="showEventLog">Show Event Log</label>
                            </div>
                        </div>
                    </li>
                    <li>
                        <div class="dropdown-item">
                            <label for="debugLevel" class="form-label">Debug Level</label>
                            <select class="form-select form-select-sm" id="debugLevel">
                                <option value="verbose">Verbose</option>
                                <option value="info" selected>Info</option>
                                <option value="warn">Warnings</option>
                                <option value="error">Errors Only</option>
                            </select>
                        </div>
                    </li>
                    <li><hr class="dropdown-divider"></li>
                    <li><button class="dropdown-item" id="resetGraphBtn">Reset Graph</button></li>
                    <li><button class="dropdown-item" id="dumpStateBtn">Dump Graph State</button></li>
                </ul>
            </div>
        </div>
    </div>
    <div class="card-body position-relative">
        <div id="graph-container"></div>
        <div id="debug-info" class="debug-info" style="display: none; max-height: 300px; overflow-y: auto;"></div>
        <div id="event-log" class="debug-info" style="display: none; bottom: auto; top: 10px; left: 10px; max-height: 200px; overflow-y: auto;"></div>

        <div class="graph-controls">
            <h6>Relationship Types</h6>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4e79a7;"></div>
                <span>Association</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #9467bd;"></div>
                <span>Causation</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #8c564b;"></div>
                <span>Sequence</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #d62728;"></div>
                <span>Contains</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #17becf;"></div>
                <span>Part Of</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #59a14f;"></div>
                <span>Reference</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #bcbd22;"></div>
                <span>PrecededBy</span>
            </div>

            <h6 class="mt-3">Node Categories</h6>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4e79a7;"></div>
                <span>Work</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f28e2c;"></div>
                <span>Personal</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #59a14f;"></div>
                <span>Research</span>
            </div>
        </div>
    </div>
</div>

<div class="card shadow">
    <div class="card-header bg-light">
        <h5 class="card-title mb-0">Memory List</h5>
    </div>
    <div class="card-body">
        <div class="table-responsive">
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Title</th>
                        <th>Category</th>
                        <th>Importance</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for node in nodes %}
                        <tr>
                            <td>{{ node.title }}</td>
                            <td>{{ node.category }}</td>
                            <td>{{ "%.1f"|format(node.importance) }}</td>
                            <td>
                                <div class="btn-group btn-group-sm">
                                    <a href="{{ url_for('view_memory', memory_id=node.id) }}" class="btn btn-outline-primary">View</a>
                                    <a href="{{ url_for('view_connections', memory_id=node.id) }}" class="btn btn-outline-secondary">Connections</a>
                                </div>
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    /**
     * Memory Network Graph Visualization
     */

    // Debug settings
    let DEBUG = false; // Debug mode starts off by default
    let DEBUG_LEVEL = 'info'; // Debug level: 'verbose', 'info', 'warn', 'error'

    // Debug logging
    const eventLog = [];
    const MAX_LOG_ENTRIES = 30;

    // Debug function with timestamp and event logging
    function debug(message, type = 'info') {
        // Always log errors regardless of debug setting
        if (!DEBUG && type !== 'error') {
            return;
        }

        // Filter based on debug level
        const debugLevels = {
            'verbose': 0,
            'info': 1,
            'warn': 2,
            'error': 3
        };

        if (debugLevels[type] < debugLevels[DEBUG_LEVEL]) {
            return;
        }

        const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
        const logMessage = `[${timestamp}] ${message}`;

        // Log to console with appropriate styling
        switch (type) {
            case 'error':
                console.error(`[Graph Debug] ${logMessage}`);
                break;
            case 'warn':
                console.warn(`[Graph Debug] ${logMessage}`);
                break;
            default:
                console.log(`[Graph Debug] ${logMessage}`);
        }

        // Update the main debug info panel
        const debugEl = document.getElementById('debug-info');
        if (debugEl && debugEl.style.display !== 'none') {
            // Keep the most recent message in the main debug panel
            debugEl.textContent = message;
        }

        // Add to event log
        eventLog.unshift(logMessage);
        if (eventLog.length > MAX_LOG_ENTRIES) {
            eventLog.pop();
        }

        // Update the event log panel
        const eventLogEl = document.getElementById('event-log');
        if (eventLogEl && eventLogEl.style.display !== 'none') {
            eventLogEl.innerHTML = eventLog.map(entry => `<div>${entry}</div>`).join('');
        }
    }

    // Log uncaught errors
    window.addEventListener('error', (event) => {
        debug(`ERROR: ${event.message} at ${event.filename}:${event.lineno}`, 'error');
    });

    // Graph data from the server
    const graphData = {
        nodes: {{ nodes|tojson }},
        links: {{ edges|tojson }}
    };

    debug(`Graph data loaded: ${graphData.nodes.length} nodes, ${graphData.links.length} links`);

    // Only initialize the graph if we have data
    if (graphData.nodes.length === 0) {
        document.getElementById('graph-container').innerHTML =
            '<div class="alert alert-info mt-3">No memories found to display in the graph. Create memories to visualize them.</div>';
    } else if (graphData.links.length === 0) {
        document.getElementById('graph-container').innerHTML =
            '<div class="alert alert-info mt-3">No connections between memories. Create connections to visualize the graph.</div>';
    } else {
        // Prepare the graph container
        const graphContainer = document.getElementById('graph-container');
        graphContainer.style.minHeight = '600px';

        // Color mappings for relationship types
        const typeColors = {
            'association': '#4e79a7',
            'causation': '#9467bd',
            'sequence': '#8c564b',
            'contains': '#d62728',
            'partof': '#17becf',
            'reference': '#59a14f',
            'predecessor': '#f28e2c',
            'successor': '#e15759',
            'precededby': '#bcbd22',
            'default': '#76b7b2'
        };

        // Color mappings for node categories
        const categoryColors = {
            'work': '#4e79a7',
            'personal': '#f28e2c',
            'research': '#59a14f',
            'uncategorized': '#76b7b2',
            'default': '#76b7b2'
        };

        // Filter valid links (where both source and target exist)
        const nodeIds = new Set(graphData.nodes.map(node => node.id));
        const validLinks = graphData.links.filter(link =>
            nodeIds.has(link.source) && nodeIds.has(link.target)
        );

        debug(`Valid links: ${validLinks.length} of ${graphData.links.length}`);

        // Create normalized node and link arrays
        // First create nodes to ensure all node objects exist
        const nodes = graphData.nodes.map(node => ({
            id: node.id,
            title: node.title || 'Untitled',
            category: (node.category || 'uncategorized').toLowerCase(),
            importance: node.importance || 0.5,
            color: categoryColors[(node.category || 'uncategorized').toLowerCase()] || categoryColors.default
        }));

        // Create a Map of nodes by ID for direct reference
        const nodeMap = {};
        nodes.forEach(node => {
            nodeMap[node.id] = node;
        });

        debug(`Node map created with ${Object.keys(nodeMap).length} entries`);

        // Now create links with direct node references - THIS FIXES THE ERROR
        const links = [];
        validLinks.forEach(link => {
            // Check if both source and target nodes exist
            const sourceNode = nodeMap[link.source];
            const targetNode = nodeMap[link.target];

            if (sourceNode && targetNode) {
                links.push({
                    // Use the actual node objects instead of just IDs
                    source: sourceNode,
                    target: targetNode,
                    type: (link.type || 'default').toLowerCase(),
                    strength: link.strength || 0.5,
                    color: typeColors[(link.type || 'default').toLowerCase()] || typeColors.default
                });
            } else {
                debug(`WARNING: Skipping link with invalid source/target: ${link.source} -> ${link.target}`, 'warn');
            }
        });

        debug(`Created ${links.length} links with direct node references`);

        // Define physics configuration parameters
        let linkDistance = 100;
        let chargeStrength = -150;

        // Reference to the graph instance
        let graph = null;

        // DOM element references
        const layoutSelect = document.getElementById('layoutAlgorithm');
        const nodeLabelsCheckbox = document.getElementById('showNodeLabels');
        const linkLabelsCheckbox = document.getElementById('showLinkLabels');
        const zoomInButton = document.getElementById('zoomInBtn');
        const zoomOutButton = document.getElementById('zoomOutBtn');
        const resetButton = document.getElementById('resetBtn');
        const expandButton = document.getElementById('expandBtn');
        const contractButton = document.getElementById('contractBtn');

        /**
         * Creates a new graph instance with the specified layout configuration
         */
        function createGraph(layoutType = 'd3') {
            debug(`Creating graph with layout: ${layoutType}`);
            debug(`Graph data: ${nodes.length} nodes, ${links.length} links`);

            // Display debug info element with important details
            const debugEl = document.getElementById('debug-info');
            if (debugEl) {
                debugEl.style.display = 'block';
                debugEl.innerHTML = `
                    Layout: ${layoutType}<br>
                    Nodes: ${nodes.length}<br>
                    Links: ${links.length}<br>
                    Link Distance: ${linkDistance}<br>
                    Charge Strength: ${chargeStrength}<br>
                `;
            }

            // Clear the container
            debug('Clearing graph container');
            graphContainer.innerHTML = '';

            // Initialize base graph with common settings
            graph = ForceGraph()
                (graphContainer)
                .graphData({ nodes, links })
                .nodeId('id')
                .nodeVal(node => 5 + node.importance * 10)
                .nodeLabel(node => `${node.title} (${node.category})`)
                .nodeColor(node => node.color)
                .linkDirectionalArrowLength(6)
                .linkDirectionalArrowRelPos(1)
                .linkCurvature(0.2)
                .cooldownTime(3000);

            // Reset forces
            graph
                .d3Force('link', null)
                .d3Force('charge', null)
                .d3Force('center', null)
                .d3Force('radial', null);

            // Apply layout-specific configuration
            switch (layoutType) {
                case 'forceAtlas2':
                    debug('Applying ForceAtlas2-like physics');
                    // ForceAtlas2-like configuration using d3 forces

                    // Strong charge force with longer range
                    const chargeForce = d3.forceManyBody()
                        .strength(chargeStrength * 2) // Stronger repulsion
                        .distanceMax(500);

                    // Custom link force with more strength - NO ID ACCESSOR NEEDED WITH DIRECT REFERENCES
                    const linkForce = d3.forceLink(links)
                        .distance(linkDistance * 1.2)
                        .strength(0.3); // Stronger links

                    // Add a weak radial force to prevent nodes from going too far
                    const radialForce = d3.forceRadial(0, 0, 0)
                        .strength(0.05);

                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce)
                        .d3Force('center', d3.forceCenter())
                        .d3Force('radial', radialForce)
                        .d3AlphaDecay(0.01) // Slower decay for more movement
                        .d3VelocityDecay(0.2); // Less friction
                    break;

                case 'ngraph':
                    debug('Applying Ngraph-like physics');
                    // Ngraph-like configuration using d3 forces

                    // Fast movement with less charge repulsion
                    const ngChargeForce = d3.forceManyBody()
                        .strength(chargeStrength / 2) // Less repulsion
                        .distanceMax(200)
                        .theta(0.9); // Faster but less accurate

                    // Weaker links for more freedom of movement - NO ID ACCESSOR NEEDED
                    const ngLinkForce = d3.forceLink(links)
                        .distance(linkDistance * 0.8)
                        .strength(0.1); // Weaker links

                    graph
                        .d3Force('link', ngLinkForce)
                        .d3Force('charge', ngChargeForce)
                        .d3Force('center', d3.forceCenter())
                        .d3AlphaDecay(0.05) // Faster decay
                        .d3VelocityDecay(0.4); // More friction
                    break;

                case 'd3':
                default:
                    debug('Applying D3 physics');

                    // Standard balanced D3 force layout
                    debug('Creating D3 link force with direct node references');
                    // No need for id accessor as links already have direct node references
                    const d3LinkForce = d3.forceLink(links)
                        .distance(linkDistance)
                        .strength(0.2);

                    // Debug link IDs
                    debug(`First few links: ${JSON.stringify(links.slice(0, 3))}`);

                    const d3ChargeForce = d3.forceManyBody()
                        .strength(chargeStrength)
                        .distanceMax(300);

                    graph
                        .d3Force('link', d3LinkForce)
                        .d3Force('charge', d3ChargeForce)
                        .d3Force('center', d3.forceCenter())
                        .d3AlphaDecay(0.02)
                        .d3VelocityDecay(0.3);
                    break;
            }

            // Set up custom node rendering
            graph.nodeCanvasObject((node, ctx, globalScale) => {
                // Node size based on importance
                const size = 5 + node.importance * 10;

                // Node circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, 2 * Math.PI);
                ctx.fillStyle = node.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5 / globalScale;
                ctx.stroke();

                // Draw node labels if enabled
                if (nodeLabelsCheckbox.checked) {
                    const fontSize = 12 / globalScale;
                    const label = node.title;

                    // Draw background for better readability
                    ctx.font = `${fontSize}px Sans-Serif`;
                    const textWidth = ctx.measureText(label).width;
                    const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.4);

                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(
                        node.x - bckgDimensions[0] / 2,
                        node.y + size + 2,
                        bckgDimensions[0],
                        bckgDimensions[1]
                    );

                    // Draw text
                    ctx.font = `${fontSize}px Sans-Serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#333';
                    ctx.fillText(
                        label,
                        node.x,
                        node.y + size + 2 + bckgDimensions[1]/2
                    );
                }
            });

            // Set up custom link rendering
            graph.linkCanvasObject((link, ctx, globalScale) => {
                // Get source and target positions
                const source = link.source;
                const target = link.target;

                // Skip if positions aren't available
                if (!source || !target || typeof source.x !== 'number' || typeof target.x !== 'number') {
                    return;
                }

                // Draw link line
                const stroke = link.color;
                const lineWidth = Math.max(1, link.strength * 3);

                ctx.beginPath();
                ctx.strokeStyle = stroke;
                ctx.lineWidth = lineWidth;
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();

                // Draw directional arrow
                const arrowLength = 6;
                const arrowRelPos = 1;

                // Calculate arrow position
                const vLine = { x: target.x - source.x, y: target.y - source.y };
                const lLine = Math.sqrt(Math.pow(vLine.x, 2) + Math.pow(vLine.y, 2));
                const posRelativeToLine = Math.min(1, arrowRelPos);
                const arrowX = source.x + (vLine.x * posRelativeToLine);
                const arrowY = source.y + (vLine.y * posRelativeToLine);

                // Calculate arrow angle
                const arrowAngle = Math.atan2(target.y - source.y, target.x - source.x);

                // Draw the arrow
                ctx.save();
                ctx.translate(arrowX, arrowY);
                ctx.rotate(arrowAngle);
                ctx.beginPath();
                ctx.moveTo(-arrowLength, -arrowLength * 0.5);
                ctx.lineTo(0, 0);
                ctx.lineTo(-arrowLength, arrowLength * 0.5);
                ctx.fillStyle = stroke;
                ctx.fill();
                ctx.restore();

                // Draw link labels if enabled and zoomed in enough
                if (linkLabelsCheckbox.checked && globalScale >= 1.2) {
                    // Position at the middle of the link
                    const midX = source.x + (target.x - source.x) / 2;
                    const midY = source.y + (target.y - source.y) / 2;

                    // Prepare the label
                    const label = `${link.type} (${link.strength.toFixed(1)})`;
                    const fontSize = Math.max(14, 14 / globalScale);

                    ctx.font = `${fontSize}px Sans-Serif`;
                    const textWidth = ctx.measureText(label).width;
                    const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.4);

                    // Draw background for better readability
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(
                        midX - bckgDimensions[0] / 2,
                        midY - bckgDimensions[1] / 2,
                        bckgDimensions[0],
                        bckgDimensions[1]
                    );

                    // Draw text
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#333';
                    ctx.fillText(label, midX, midY);
                }
            }).linkCanvasObjectMode(() => 'replace');

            // Store all nodes by ID for easy lookup during events
            const nodesById = {};
            nodes.forEach(node => {
                nodesById[node.id] = node;
            });

            // ===== DOUBLE-CLICK FIX =====
            // Track node click state for double-click detection
            let lastClickedNodeId = null;
            let lastClickTime = 0;
            const DOUBLE_CLICK_THRESHOLD = 400; // ms

            // Log node hovers for debugging
            graph.onNodeHover(node => {
                if (node) {
                    debug(`Node hover: ${node.id} (${node.title})`);
                }
            });

            // FIRST METHOD: Using the built-in click handler
            graph.onNodeClick(node => {
                if (!node || !node.id) {
                    debug('Click on invalid node', 'warn');
                    return;
                }

                const now = Date.now();
                debug(`Node clicked: ${node.id} (${node.title})`);

                if (lastClickedNodeId === node.id && now - lastClickTime < DOUBLE_CLICK_THRESHOLD) {
                    // Double-click detected
                    debug(`DOUBLE-CLICK detected on node: ${node.id}`);
                    try {
                        const url = `{{ url_for('view_memory', memory_id='NODE_ID') }}`.replace('NODE_ID', node.id);
                        debug(`Navigating to: ${url}`);
                        window.location.href = url;
                    } catch (err) {
                        debug(`ERROR in navigation: ${err.message}`, 'error');
                    }
                    lastClickedNodeId = null; // Reset tracking
                } else {
                    // First click - highlight the node
                    debug(`First click on node: ${node.id}`);
                    lastClickedNodeId = node.id;
                    lastClickTime = now;

                    // Focus on the clicked node
                    graph.centerAt(node.x, node.y, 800);
                }
            });

            // SECOND METHOD: Implement direct node detection in double-click
            graphContainer.addEventListener('dblclick', event => {
                debug(`Double-click detected at x:${event.clientX}, y:${event.clientY}`);

                // The Force Graph library should handle this internally,
                // but we'll add this as a fallback direct handling.
                // We'll auto-navigate to the currently focused node for simplicity.
                if (lastClickedNodeId) {
                    debug(`Direct navigation for double-click on node: ${lastClickedNodeId}`);
                    try {
                        const url = `{{ url_for('view_memory', memory_id='NODE_ID') }}`.replace('NODE_ID', lastClickedNodeId);
                        debug(`Double-click - navigating to: ${url}`);
                        window.location.href = url;
                    } catch (err) {
                        debug(`ERROR in double-click navigation: ${err.message}`, 'error');
                    }
                }
            });

            // Show a dedicated "Open Node" button for better UX
            function createOpenNodeButton(nodeId) {
                // Remove any existing button
                const existingBtn = document.getElementById('open-node-btn');
                if (existingBtn) {
                    existingBtn.remove();
                }

                // Create new button
                const openBtn = document.createElement('button');
                openBtn.id = 'open-node-btn';
                openBtn.textContent = 'Open Selected Node';
                openBtn.className = 'btn btn-sm btn-primary position-absolute';
                openBtn.style.top = '10px';
                openBtn.style.left = '50%';
                openBtn.style.transform = 'translateX(-50%)';
                openBtn.style.zIndex = '1000';

                // Add click handler
                openBtn.addEventListener('click', () => {
                    debug(`Open button clicked for node: ${nodeId}`);
                    try {
                        const url = `{{ url_for('view_memory', memory_id='NODE_ID') }}`.replace('NODE_ID', nodeId);
                        debug(`Navigating to: ${url}`);
                        window.location.href = url;
                    } catch (err) {
                        debug(`ERROR in navigation: ${err.message}`, 'error');
                    }
                });

                // Add to container
                graphContainer.parentNode.appendChild(openBtn);

                return openBtn;
            }

            // Update the node click handler to show the button
            const originalOnNodeClick = graph.onNodeClick();
            graph.onNodeClick(node => {
                // Call the original handler if it exists
                if (originalOnNodeClick) originalOnNodeClick(node);

                // Show the open button for this node
                if (node && node.id) {
                    debug(`Creating open button for node: ${node.id}`);
                    createOpenNodeButton(node.id);
                }
            });

            // Warm up the simulation - using safer approach without method chaining
            try {
                debug('Warming up simulation');
                graph.cooldownTicks(0); // Prevent simulation from ending

                // Try different methods to reset/warm up the simulation
                if (typeof graph.resetForceSimulation === 'function') {
                    graph.resetForceSimulation();
                } else {
                    // Fallback: Refresh the graph data to trigger simulation
                    const currentData = graph.graphData();
                    graph.graphData({...currentData});
                }

                // Cool down after warm-up
                setTimeout(() => {
                    graph.cooldownTicks(50); // Allow simulation to end naturally
                    graph.zoomToFit(400);
                }, 1000);
            } catch (err) {
                debug(`ERROR in simulation warmup: ${err}`, 'error');
                console.error('Simulation warmup error:', err);
            }

            return graph;
        }

        /**
         * Expands the graph by increasing link distance and decreasing charge strength
         */
        function expandGraph() {
            debug('Expanding graph');

            // Update physics parameters
            linkDistance += 50;
            chargeStrength -= 50;

            debug(`New parameters: linkDistance=${linkDistance}, chargeStrength=${chargeStrength}`);

            // Apply changes based on current layout
            const layoutType = layoutSelect.value;

            // Dump current graph state to help with debugging
            dumpGraphState();

            // Get the current graph data
            const currentGraphData = graph.graphData();
            debug(`Current graph data: ${currentGraphData.nodes.length} nodes, ${currentGraphData.links.length} links`);

            // Reset the simulation with new parameters
            let linkForce, chargeForce, radialForce;

            switch (layoutType) {
                case 'forceAtlas2':
                    debug('Updating ForceAtlas2 forces for expand');
                    // ForceAtlas2-like setup with new parameters
                    chargeForce = d3.forceManyBody()
                        .strength(chargeStrength * 2)
                        .distanceMax(500);

                    // FIXED: No id accessor needed with direct node references
                    linkForce = d3.forceLink(currentGraphData.links)
                        .distance(linkDistance * 1.2)
                        .strength(0.3);

                    radialForce = d3.forceRadial(0, 0, 0)
                        .strength(0.05);

                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce)
                        .d3Force('radial', radialForce);
                    break;

                case 'ngraph':
                    debug('Updating Ngraph forces for expand');
                    // Ngraph-like setup with new parameters
                    chargeForce = d3.forceManyBody()
                        .strength(chargeStrength / 2)
                        .distanceMax(200)
                        .theta(0.9);

                    // FIXED: No id accessor needed
                    linkForce = d3.forceLink(currentGraphData.links)
                        .distance(linkDistance * 0.8)
                        .strength(0.1);

                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce);
                    break;

                case 'd3':
                default:
                    debug('Updating D3 forces for expand');
                    // Standard D3 force layout with new parameters

                    // FIXED: No id accessor needed with direct node references
                    linkForce = d3.forceLink(currentGraphData.links)
                        .distance(linkDistance)
                        .strength(0.2);

                    chargeForce = d3.forceManyBody()
                        .strength(chargeStrength)
                        .distanceMax(300);

                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce);
                    break;
            }

            // Reheat the simulation - safer approach without method chaining
            try {
                debug('Reheating simulation after expand');

                // Set cooldown ticks to 0 to keep running
                graph.cooldownTicks(0);

                // Try different methods to restart the simulation
                if (typeof graph.resetForceSimulation === 'function') {
                    graph.resetForceSimulation();
                } else {
                    // Fallback: Slightly perturb node positions to restart
                    const data = graph.graphData();
                    data.nodes.forEach(node => {
                        node.x += (Math.random() - 0.5) * 0.5;
                        node.y += (Math.random() - 0.5) * 0.5;
                    });
                    graph.graphData(data);
                }

                // Allow simulation to end after a delay
                setTimeout(() => {
                    debug('Cooling down simulation');
                    graph.cooldownTicks(50);
                }, 1000);
            } catch (err) {
                debug(`ERROR in expand graph: ${err}`, 'error');
                console.error('Expand error:', err);
            }
        }

        /**
         * Contracts the graph by decreasing link distance and increasing charge strength
         */
        function contractGraph() {
            debug('Contracting graph');

            // Update physics parameters with limits
            linkDistance = Math.max(50, linkDistance - 50);
            chargeStrength = Math.min(-50, chargeStrength + 50);

            debug(`New parameters: linkDistance=${linkDistance}, chargeStrength=${chargeStrength}`);

            // Apply changes based on current layout
            const layoutType = layoutSelect.value;

            // Dump graph state for debugging
            dumpGraphState();

            // Get the current graph data
            const currentGraphData = graph.graphData();
            debug(`Current graph data: ${currentGraphData.nodes.length} nodes, ${currentGraphData.links.length} links`);

            // Reset the simulation with new parameters
            let linkForce, chargeForce, radialForce;

            switch (layoutType) {
                case 'forceAtlas2':
                    debug('Updating ForceAtlas2 forces for contract');
                    // ForceAtlas2-like setup with new parameters
                    chargeForce = d3.forceManyBody()
                        .strength(chargeStrength * 2)
                        .distanceMax(500);

                    // FIXED: No id accessor needed with direct node references
                    linkForce = d3.forceLink(currentGraphData.links)
                        .distance(linkDistance * 1.2)
                        .strength(0.3);

                    radialForce = d3.forceRadial(0, 0, 0)
                        .strength(0.05);

                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce)
                        .d3Force('radial', radialForce);
                    break;

                case 'ngraph':
                    debug('Updating Ngraph forces for contract');
                    // Ngraph-like setup with new parameters
                    chargeForce = d3.forceManyBody()
                        .strength(chargeStrength / 2)
                        .distanceMax(200)
                        .theta(0.9);

                    // FIXED: No id accessor needed
                    linkForce = d3.forceLink(currentGraphData.links)
                        .distance(linkDistance * 0.8)
                        .strength(0.1);

                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce);
                    break;

                case 'd3':
                default:
                    debug('Updating D3 forces for contract');
                    // Standard D3 force layout with new parameters

                    // FIXED: No id accessor needed with direct node references
                    linkForce = d3.forceLink(currentGraphData.links)
                        .distance(linkDistance)
                        .strength(0.2);

                    chargeForce = d3.forceManyBody()
                        .strength(chargeStrength)
                        .distanceMax(300);

                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce);
                    break;
            }

            // Reheat the simulation - safer approach without method chaining
            try {
                debug('Reheating simulation after contract');

                // Set cooldown ticks to 0 to keep running
                graph.cooldownTicks(0);

                // Try different methods to restart the simulation
                if (typeof graph.resetForceSimulation === 'function') {
                    graph.resetForceSimulation();
                } else {
                    // Fallback: Slightly perturb node positions to restart
                    const data = graph.graphData();
                    data.nodes.forEach(node => {
                        node.x += (Math.random() - 0.5) * 0.5;
                        node.y += (Math.random() - 0.5) * 0.5;
                    });
                    graph.graphData(data);
                }

                // Allow simulation to end after a delay
                setTimeout(() => {
                    debug('Cooling down simulation');
                    graph.cooldownTicks(50);
                }, 1000);
            } catch (err) {
                debug(`ERROR in contract graph: ${err}`, 'error');
                console.error('Contract error:', err);
            }
        }

        // Initialize the graph with default layout
        graph = createGraph('d3');

        // Function to show graph's internal state for debugging
        function dumpGraphState() {
            if (!graph) {
                debug('Cannot dump graph state - graph is null', 'warn');
                return;
            }

            try {
                const state = {
                    graphData: graph.graphData(),
                    numNodes: graph.graphData().nodes.length,
                    numLinks: graph.graphData().links.length,
                    currentZoom: graph.zoom(),
                    forces: {}
                };

                // Try to get D3 force information
                const forceNames = ['link', 'charge', 'center', 'radial'];
                forceNames.forEach(forceName => {
                    const force = graph.d3Force(forceName);
                    state.forces[forceName] = force ? 'active' : 'not set';
                });

                debug(`Graph state dump: ${JSON.stringify(state, null, 2)}`, 'info');
                return state;
            } catch (err) {
                debug(`ERROR dumping graph state: ${err.message}`, 'error');
                console.error(err);
            }
        }

        // ===== EVENT HANDLERS =====

        // Get Settings menu controls
        const enableDebugToggle = document.getElementById('enableDebug');
        const showDebugOverlayToggle = document.getElementById('showDebugOverlay');
        const showEventLogToggle = document.getElementById('showEventLog');
        const debugLevelSelect = document.getElementById('debugLevel');
        const resetGraphBtn = document.getElementById('resetGraphBtn');
        const dumpStateBtn = document.getElementById('dumpStateBtn');

        // Toggle debugging
        enableDebugToggle.addEventListener('change', function() {
            DEBUG = this.checked;
            debug(`Debugging ${DEBUG ? 'enabled' : 'disabled'}`);

            // If turning off debug, also hide panels
            if (!DEBUG) {
                const debugEl = document.getElementById('debug-info');
                const logEl = document.getElementById('event-log');
                if (debugEl) debugEl.style.display = 'none';
                if (logEl) logEl.style.display = 'none';

                // Update toggles
                showDebugOverlayToggle.checked = false;
                showEventLogToggle.checked = false;
            }
        });

        // Toggle debug overlay
        showDebugOverlayToggle.addEventListener('change', function() {
            const debugEl = document.getElementById('debug-info');
            if (debugEl) {
                debugEl.style.display = this.checked ? 'block' : 'none';
                debug(`Debug overlay ${this.checked ? 'shown' : 'hidden'}`);
            }

            // If showing debug overlay, ensure debug is enabled
            if (this.checked && !DEBUG) {
                DEBUG = true;
                enableDebugToggle.checked = true;
                debug('Debugging automatically enabled');
            }
        });

        // Toggle event log
        showEventLogToggle.addEventListener('change', function() {
            const logEl = document.getElementById('event-log');
            if (logEl) {
                logEl.style.display = this.checked ? 'block' : 'none';
                debug(`Event log ${this.checked ? 'shown' : 'hidden'}`);
            }

            // If showing event log, ensure debug is enabled
            if (this.checked && !DEBUG) {
                DEBUG = true;
                enableDebugToggle.checked = true;
                debug('Debugging automatically enabled');
            }
        });

        // Change debug level
        debugLevelSelect.addEventListener('change', function() {
            DEBUG_LEVEL = this.value;
            debug(`Debug level set to: ${DEBUG_LEVEL}`);
        });

        // Dump state button
        dumpStateBtn.addEventListener('click', function() {
            debug('Manual state dump requested');
            dumpGraphState();
        });

        // Reset graph button
        resetGraphBtn.addEventListener('click', function() {
            try {
                debug('Reset graph button clicked - recreating graph with current layout');
                if (graph) {
                    const currentLayout = layoutSelect.value;
                    graph = createGraph(currentLayout);
                    debug(`Graph recreated with layout: ${currentLayout}`);
                } else {
                    debug('Cannot reset graph - graph is null', 'warn');
                }
            } catch (err) {
                debug(`ERROR in reset graph: ${err.message}`, 'error');
                console.error(err);
            }
        });

        // Add detailed mouse tracking for debugging
        graphContainer.addEventListener('mousemove', (event) => {
            // Uncomment the next line for very verbose debugging
            // debug(`Mouse move at x:${event.clientX}, y:${event.clientY}`);
        });

        // Track all mouse events on the container
        ['mousedown', 'mouseup', 'dblclick'].forEach(eventType => {
            graphContainer.addEventListener(eventType, (event) => {
                debug(`Mouse event: ${eventType} at x:${event.clientX}, y:${event.clientY}`);
            });
        });

        // Handle layout algorithm changes
        layoutSelect.addEventListener('change', function() {
            try {
                debug(`Changing layout to: ${this.value}`);

                // Recreate graph with new layout
                debug('About to call createGraph()');
                graph = createGraph(this.value);
                debug('Graph recreated successfully');
            } catch (err) {
                debug(`ERROR in layout change: ${err.message}`, 'error');
                console.error(err);
            }
        });

        // Toggle handlers for labels
        nodeLabelsCheckbox.addEventListener('change', function() {
            try {
                debug(`Node labels toggled: ${this.checked}`);
                if (graph) {
                    debug('Refreshing graph to show/hide node labels');
                    // Force a redraw by slightly changing a property and restoring it
                    const currentNodeVal = graph.nodeVal();
                    graph.nodeVal(currentNodeVal); // This triggers a redraw
                } else {
                    debug('Cannot toggle node labels - graph is null', 'warn');
                }
            } catch (err) {
                debug(`ERROR in node labels toggle: ${err.message}`, 'error');
                console.error(err);
            }
        });

        linkLabelsCheckbox.addEventListener('change', function() {
            try {
                debug(`Link labels toggled: ${this.checked}`);
                if (graph) {
                    debug('Refreshing graph to show/hide link labels');
                    // Force a redraw by slightly changing a property and restoring it
                    const currentNodeVal = graph.nodeVal();
                    graph.nodeVal(currentNodeVal); // This triggers a redraw
                } else {
                    debug('Cannot toggle link labels - graph is null', 'warn');
                }
            } catch (err) {
                debug(`ERROR in link labels toggle: ${err.message}`, 'error');
                console.error(err);
            }
        });

        // Button handlers with enhanced error tracking
        zoomInButton.addEventListener('click', function() {
            try {
                debug('Zoom in button clicked');
                if (graph) {
                    const currentZoom = graph.zoom();
                    debug(`Current zoom: ${currentZoom}, zooming to: ${currentZoom * 1.5}`);
                    graph.zoom(currentZoom * 1.5);
                } else {
                    debug('Cannot zoom in - graph is null', 'warn');
                }
            } catch (err) {
                debug(`ERROR in zoom in: ${err.message}`, 'error');
                console.error(err);
            }
        });

        zoomOutButton.addEventListener('click', function() {
            try {
                debug('Zoom out button clicked');
                if (graph) {
                    const currentZoom = graph.zoom();
                    debug(`Current zoom: ${currentZoom}, zooming to: ${currentZoom / 1.5}`);
                    graph.zoom(currentZoom / 1.5);
                } else {
                    debug('Cannot zoom out - graph is null', 'warn');
                }
            } catch (err) {
                debug(`ERROR in zoom out: ${err.message}`, 'error');
                console.error(err);
            }
        });

        resetButton.addEventListener('click', function() {
            try {
                debug('Reset view button clicked');
                if (graph) {
                    debug('Zooming to fit all nodes');
                    graph.zoomToFit(400);
                } else {
                    debug('Cannot reset view - graph is null', 'warn');
                }
            } catch (err) {
                debug(`ERROR in reset view: ${err.message}`, 'error');
                console.error(err);
            }
        });

        expandButton.addEventListener('click', function() {
            try {
                debug('Expand button clicked');
                if (graph) {
                    expandGraph();
                } else {
                    debug('Cannot expand graph - graph is null', 'warn');
                }
            } catch (err) {
                debug(`ERROR in expand: ${err.message}`, 'error');
                console.error(err);
            }
        });

        contractButton.addEventListener('click', function() {
            try {
                debug('Contract button clicked');
                if (graph) {
                    contractGraph();
                } else {
                    debug('Cannot contract graph - graph is null', 'warn');
                }
            } catch (err) {
                debug(`ERROR in contract: ${err.message}`, 'error');
                console.error(err);
            }
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            if (graph) {
                graph.width(graphContainer.clientWidth);
                graph.height(graphContainer.clientHeight);
            }
        });

        // Initial setup
        debug('Graph initialization complete');
    }
</script>
{% endblock %}