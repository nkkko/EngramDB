{% extends "base.html" %}

{% block title %}EngramDB - Memory Graph{% endblock %}

{% block header %}Memory Network Visualization{% endblock %}

{% block head %}
<!-- D3.js for graph visualization -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<!-- Force Graph library -->
<script src="https://unpkg.com/force-graph"></script>
<style>
    #graph-container {
        width: 100%;
        height: 600px;
        border: 1px solid #ddd;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
    }
    .graph-controls {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 10;
        background-color: rgba(255,255,255,0.9);
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        max-height: 500px;
        overflow-y: auto;
        width: 200px;
        transition: all 0.3s ease;
    }
    .graph-controls:hover {
        background-color: rgba(255,255,255,1);
    }
    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 7px;
        font-size: 0.85rem;
    }
    .legend-color {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        border-radius: 3px;
        border: 1px solid rgba(0,0,0,0.1);
    }
    .graph-controls h6 {
        margin-top: 0;
        margin-bottom: 10px;
        font-weight: 600;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
    }
    .debug-info {
        position: absolute;
        bottom: 10px;
        left: 10px;
        font-size: 12px;
        color: #666;
        background: rgba(255,255,255,0.8);
        padding: 5px;
        border-radius: 4px;
        max-width: 400px;
        z-index: 100;
    }
</style>
{% endblock %}

{% block content %}
<div class="card shadow mb-4">
    <div class="card-header bg-light d-flex justify-content-between align-items-center">
        <h5 class="card-title mb-0">Memory Graph</h5>
        <div class="d-flex align-items-center flex-wrap">
            <div class="form-check form-switch me-3 mb-2">
                <input class="form-check-input" type="checkbox" id="showNodeLabels">
                <label class="form-check-label" for="showNodeLabels">Node Labels</label>
            </div>
            <div class="form-check form-switch me-3 mb-2">
                <input class="form-check-input" type="checkbox" id="showLinkLabels">
                <label class="form-check-label" for="showLinkLabels">Link Labels</label>
            </div>
            <div class="input-group input-group-sm me-3 mb-2" style="width: 200px;">
                <label class="input-group-text" for="layoutAlgorithm">Layout</label>
                <select class="form-select form-select-sm" id="layoutAlgorithm">
                    <option value="d3">D3 Force</option>
                    <option value="forceAtlas2">Force Atlas 2</option>
                    <option value="ngraph">Ngraph (Fast)</option>
                </select>
            </div>
            <div class="btn-group me-3 mb-2">
                <button class="btn btn-sm btn-outline-secondary" id="zoomInBtn" title="Zoom In">
                    <i class="bi bi-zoom-in"></i>
                </button>
                <button class="btn btn-sm btn-outline-secondary" id="zoomOutBtn" title="Zoom Out">
                    <i class="bi bi-zoom-out"></i>
                </button>
                <button class="btn btn-sm btn-outline-secondary" id="resetBtn" title="Reset View">
                    <i class="bi bi-arrow-counterclockwise"></i>
                </button>
            </div>
            <div class="btn-group mb-2">
                <button class="btn btn-sm btn-outline-primary" id="expandBtn" title="Expand Graph">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
                <button class="btn btn-sm btn-outline-primary" id="contractBtn" title="Contract Graph">
                    <i class="bi bi-arrows-angle-contract"></i>
                </button>
            </div>
        </div>
    </div>
    <div class="card-body position-relative">
        <div id="graph-container"></div>
        <div id="debug-info" class="debug-info" style="display: none;"></div>
        
        <div class="graph-controls">
            <h6>Relationship Types</h6>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4e79a7;"></div>
                <span>Association</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #9467bd;"></div>
                <span>Causation</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #8c564b;"></div>
                <span>Sequence</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #d62728;"></div>
                <span>Contains</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #17becf;"></div>
                <span>Part Of</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #59a14f;"></div>
                <span>Reference</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #bcbd22;"></div>
                <span>PrecededBy</span>
            </div>
            
            <h6 class="mt-3">Node Categories</h6>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4e79a7;"></div>
                <span>Work</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f28e2c;"></div>
                <span>Personal</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #59a14f;"></div>
                <span>Research</span>
            </div>
        </div>
    </div>
</div>

<div class="card shadow">
    <div class="card-header bg-light">
        <h5 class="card-title mb-0">Memory List</h5>
    </div>
    <div class="card-body">
        <div class="table-responsive">
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Title</th>
                        <th>Category</th>
                        <th>Importance</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for node in nodes %}
                        <tr>
                            <td>{{ node.title }}</td>
                            <td>{{ node.category }}</td>
                            <td>{{ "%.1f"|format(node.importance) }}</td>
                            <td>
                                <div class="btn-group btn-group-sm">
                                    <a href="{{ url_for('view_memory', memory_id=node.id) }}" class="btn btn-outline-primary">View</a>
                                    <a href="{{ url_for('view_connections', memory_id=node.id) }}" class="btn btn-outline-secondary">Connections</a>
                                </div>
                            </td>
                        </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    /**
     * Memory Network Graph Visualization
     * 
     * This script creates an interactive force-directed graph visualization of memory nodes
     * and their connections. It uses the Force Graph library which is built on D3.js.
     * 
     * Features:
     * - Multiple physics engines (D3, ForceAtlas2, Ngraph)
     * - Node and link labels
     * - Zooming and panning
     * - Graph expansion/contraction
     * - Customizable node and link appearance
     * - Click-to-navigate to memory details
     */
    
    // Enable debug mode for troubleshooting
    const DEBUG = true;
    
    // Debug function
    function debug(message) {
        if (DEBUG) {
            console.log(`[Graph Debug] ${message}`);
            const debugEl = document.getElementById('debug-info');
            if (debugEl) {
                debugEl.style.display = 'block';
                debugEl.textContent = message;
            }
        }
    }
    
    // Graph data from the server
    const graphData = {
        nodes: {{ nodes|tojson }},
        links: {{ edges|tojson }}
    };
    
    debug(`Graph data loaded: ${graphData.nodes.length} nodes, ${graphData.links.length} links`);
    
    // Only initialize the graph if we have data
    if (graphData.nodes.length === 0) {
        document.getElementById('graph-container').innerHTML = 
            '<div class="alert alert-info mt-3">No memories found to display in the graph. Create memories to visualize them.</div>';
    } else if (graphData.links.length === 0) {
        document.getElementById('graph-container').innerHTML = 
            '<div class="alert alert-info mt-3">No connections between memories. Create connections to visualize the graph.</div>';
    } else {
        // Prepare the graph container
        const graphContainer = document.getElementById('graph-container');
        graphContainer.style.minHeight = '600px';
        
        // Color mappings for relationship types
        const typeColors = {
            'association': '#4e79a7',
            'causation': '#9467bd',
            'sequence': '#8c564b',
            'contains': '#d62728',
            'partof': '#17becf',
            'reference': '#59a14f',
            'predecessor': '#f28e2c',
            'successor': '#e15759',
            'precededby': '#bcbd22',
            'default': '#76b7b2'
        };
        
        // Color mappings for node categories
        const categoryColors = {
            'work': '#4e79a7',
            'personal': '#f28e2c', 
            'research': '#59a14f',
            'uncategorized': '#76b7b2',
            'default': '#76b7b2'
        };
        
        // Filter valid links (where both source and target exist)
        const nodeIds = new Set(graphData.nodes.map(node => node.id));
        const validLinks = graphData.links.filter(link => 
            nodeIds.has(link.source) && nodeIds.has(link.target)
        );
        
        debug(`Valid links: ${validLinks.length} of ${graphData.links.length}`);
        
        // Create normalized node and link arrays
        const nodes = graphData.nodes.map(node => ({
            id: node.id,
            title: node.title || 'Untitled',
            category: (node.category || 'uncategorized').toLowerCase(),
            importance: node.importance || 0.5,
            color: categoryColors[(node.category || 'uncategorized').toLowerCase()] || categoryColors.default
        }));
        
        const links = validLinks.map(link => ({
            source: link.source,
            target: link.target,
            type: (link.type || 'default').toLowerCase(),
            strength: link.strength || 0.5,
            color: typeColors[(link.type || 'default').toLowerCase()] || typeColors.default
        }));
        
        // Define physics configuration parameters
        let linkDistance = 100;
        let chargeStrength = -150;
        
        // Reference to the graph instance
        let graph = null;
        
        // DOM element references
        const layoutSelect = document.getElementById('layoutAlgorithm');
        const nodeLabelsCheckbox = document.getElementById('showNodeLabels');
        const linkLabelsCheckbox = document.getElementById('showLinkLabels');
        const zoomInButton = document.getElementById('zoomInBtn');
        const zoomOutButton = document.getElementById('zoomOutBtn');
        const resetButton = document.getElementById('resetBtn');
        const expandButton = document.getElementById('expandBtn');
        const contractButton = document.getElementById('contractBtn');
        
        /**
         * Creates a new graph instance with the specified physics engine
         */
        function createGraph(engine = 'd3') {
            debug(`Creating graph with engine: ${engine}`);
            
            // Clear the container
            graphContainer.innerHTML = '';
            
            // Initialize base graph with common settings
            graph = ForceGraph()
                (graphContainer)
                .graphData({ nodes, links })
                .nodeId('id')
                .nodeVal(node => 5 + node.importance * 10)
                .nodeLabel(node => `${node.title} (${node.category})`)
                .nodeColor(node => node.color)
                .linkDirectionalArrowLength(6)
                .linkDirectionalArrowRelPos(1)
                .linkCurvature(0.2)
                .cooldownTime(3000);
            
            // Apply engine-specific configuration
            switch (engine) {
                case 'forceAtlas2':
                    debug('Applying ForceAtlas2 physics');
                    graph
                        .forceEngine('forceAtlas2')
                        .forceAtlas2Config({
                            gravitationalConstant: chargeStrength,
                            centralGravity: 0.01,
                            springLength: linkDistance,
                            springCoefficient: 0.08,
                            damping: 0.4,
                            avoidOverlap: 1
                        });
                    break;
                    
                case 'ngraph':
                    debug('Applying Ngraph physics');
                    graph
                        .forceEngine('ngraph')
                        .ngraphPhysics({
                            timeStep: 20,
                            gravity: chargeStrength / 100,
                            theta: 0.8,
                            springLength: linkDistance,
                            springCoefficient: 0.0008,
                            dragCoefficient: 0.02
                        });
                    break;
                    
                case 'd3':
                default:
                    debug('Applying D3 physics');
                    graph
                        .forceEngine('d3')
                        .d3Force('link', d3.forceLink(links)
                            .id(d => d.id)
                            .distance(linkDistance)
                            .strength(0.2))
                        .d3Force('charge', d3.forceManyBody()
                            .strength(chargeStrength))
                        .d3Force('center', d3.forceCenter())
                        .d3AlphaDecay(0.02)
                        .d3VelocityDecay(0.3);
                    break;
            }
            
            // Set up custom node rendering
            graph.nodeCanvasObject((node, ctx, globalScale) => {
                // Node size based on importance
                const size = 5 + node.importance * 10;
                
                // Node circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, size, 0, 2 * Math.PI);
                ctx.fillStyle = node.color;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1.5 / globalScale;
                ctx.stroke();
                
                // Draw node labels if enabled
                if (nodeLabelsCheckbox.checked) {
                    const fontSize = 12 / globalScale;
                    const label = node.title;
                    
                    // Draw background for better readability
                    ctx.font = `${fontSize}px Sans-Serif`;
                    const textWidth = ctx.measureText(label).width;
                    const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.4);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(
                        node.x - bckgDimensions[0] / 2, 
                        node.y + size + 2, 
                        bckgDimensions[0],
                        bckgDimensions[1]
                    );
                    
                    // Draw text
                    ctx.font = `${fontSize}px Sans-Serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#333';
                    ctx.fillText(
                        label,
                        node.x,
                        node.y + size + 2 + bckgDimensions[1]/2
                    );
                }
            });
            
            // Set up custom link rendering
            graph.linkCanvasObject((link, ctx, globalScale) => {
                // Get source and target positions
                const source = link.source;
                const target = link.target;
                
                // Skip if positions aren't available
                if (!source || !target || typeof source.x !== 'number' || typeof target.x !== 'number') {
                    return;
                }
                
                // Draw link line
                const stroke = link.color;
                const lineWidth = Math.max(1, link.strength * 3);
                
                ctx.beginPath();
                ctx.strokeStyle = stroke;
                ctx.lineWidth = lineWidth;
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.stroke();
                
                // Draw directional arrow
                const arrowLength = 6;
                const arrowRelPos = 1;
                
                // Calculate arrow position
                const vLine = { x: target.x - source.x, y: target.y - source.y };
                const lLine = Math.sqrt(Math.pow(vLine.x, 2) + Math.pow(vLine.y, 2));
                const posRelativeToLine = Math.min(1, arrowRelPos);
                const arrowX = source.x + (vLine.x * posRelativeToLine);
                const arrowY = source.y + (vLine.y * posRelativeToLine);
                
                // Calculate arrow angle
                const arrowAngle = Math.atan2(target.y - source.y, target.x - source.x);
                
                // Draw the arrow
                ctx.save();
                ctx.translate(arrowX, arrowY);
                ctx.rotate(arrowAngle);
                ctx.beginPath();
                ctx.moveTo(-arrowLength, -arrowLength * 0.5);
                ctx.lineTo(0, 0);
                ctx.lineTo(-arrowLength, arrowLength * 0.5);
                ctx.fillStyle = stroke;
                ctx.fill();
                ctx.restore();
                
                // Draw link labels if enabled and zoomed in enough
                if (linkLabelsCheckbox.checked && globalScale >= 1.2) {
                    // Position at the middle of the link
                    const midX = source.x + (target.x - source.x) / 2;
                    const midY = source.y + (target.y - source.y) / 2;
                    
                    // Prepare the label
                    const label = `${link.type} (${link.strength.toFixed(1)})`;
                    const fontSize = Math.max(14, 14 / globalScale);
                    
                    ctx.font = `${fontSize}px Sans-Serif`;
                    const textWidth = ctx.measureText(label).width;
                    const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.4);
                    
                    // Draw background for better readability
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(
                        midX - bckgDimensions[0] / 2,
                        midY - bckgDimensions[1] / 2,
                        bckgDimensions[0],
                        bckgDimensions[1]
                    );
                    
                    // Draw text
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#333';
                    ctx.fillText(label, midX, midY);
                }
            }).linkCanvasObjectMode(() => 'replace');
            
            // Add node click handler
            graph.onNodeClick(node => {
                debug(`Clicked node: ${node.id} (${node.title})`);
                window.location.href = `{{ url_for('view_memory', memory_id='NODE_ID') }}`.replace('NODE_ID', node.id);
            });
            
            // Warm up the simulation
            graph.d3AlphaTarget(0.3).resetForceSimulation();
            
            // Cool down after warm-up
            setTimeout(() => {
                graph.d3AlphaTarget(0);
                graph.zoomToFit(400);
            }, 1000);
            
            return graph;
        }
        
        /**
         * Expands the graph by increasing link distance and decreasing charge strength
         */
        function expandGraph() {
            debug('Expanding graph');
            
            // Update physics parameters
            linkDistance += 50;
            chargeStrength -= 50;
            
            debug(`New parameters: linkDistance=${linkDistance}, chargeStrength=${chargeStrength}`);
            
            // Apply changes based on current engine
            const engine = layoutSelect.value;
            
            switch (engine) {
                case 'forceAtlas2':
                    // Update ForceAtlas2 config
                    graph.forceAtlas2Config({
                        gravitationalConstant: chargeStrength,
                        centralGravity: 0.01,
                        springLength: linkDistance,
                        springCoefficient: 0.08,
                        damping: 0.4,
                        avoidOverlap: 1
                    });
                    break;
                    
                case 'ngraph':
                    // Update Ngraph physics
                    graph.ngraphPhysics({
                        timeStep: 20,
                        gravity: chargeStrength / 100,
                        theta: 0.8,
                        springLength: linkDistance,
                        springCoefficient: 0.0008,
                        dragCoefficient: 0.02
                    });
                    break;
                    
                case 'd3':
                default:
                    // Update D3 forces
                    const linkForce = d3.forceLink(graph.graphData().links)
                        .id(d => d.id)
                        .distance(linkDistance)
                        .strength(0.2);
                        
                    const chargeForce = d3.forceManyBody()
                        .strength(chargeStrength);
                    
                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce);
                    break;
            }
            
            // Reheat the simulation
            graph.d3AlphaTarget(0.3).resetForceSimulation();
            
            // Cool down
            setTimeout(() => {
                graph.d3AlphaTarget(0);
            }, 1000);
        }
        
        /**
         * Contracts the graph by decreasing link distance and increasing charge strength
         */
        function contractGraph() {
            debug('Contracting graph');
            
            // Update physics parameters
            linkDistance = Math.max(50, linkDistance - 50);
            chargeStrength = Math.min(-50, chargeStrength + 50);
            
            debug(`New parameters: linkDistance=${linkDistance}, chargeStrength=${chargeStrength}`);
            
            // Apply changes based on current engine
            const engine = layoutSelect.value;
            
            switch (engine) {
                case 'forceAtlas2':
                    // Update ForceAtlas2 config
                    graph.forceAtlas2Config({
                        gravitationalConstant: chargeStrength,
                        centralGravity: 0.01,
                        springLength: linkDistance,
                        springCoefficient: 0.08,
                        damping: 0.4,
                        avoidOverlap: 1
                    });
                    break;
                    
                case 'ngraph':
                    // Update Ngraph physics
                    graph.ngraphPhysics({
                        timeStep: 20,
                        gravity: chargeStrength / 100,
                        theta: 0.8,
                        springLength: linkDistance,
                        springCoefficient: 0.0008,
                        dragCoefficient: 0.02
                    });
                    break;
                    
                case 'd3':
                default:
                    // Update D3 forces
                    const linkForce = d3.forceLink(graph.graphData().links)
                        .id(d => d.id)
                        .distance(linkDistance)
                        .strength(0.2);
                        
                    const chargeForce = d3.forceManyBody()
                        .strength(chargeStrength);
                    
                    graph
                        .d3Force('link', linkForce)
                        .d3Force('charge', chargeForce);
                    break;
            }
            
            // Reheat the simulation
            graph.d3AlphaTarget(0.3).resetForceSimulation();
            
            // Cool down
            setTimeout(() => {
                graph.d3AlphaTarget(0);
            }, 1000);
        }
        
        // Initialize the graph with default engine
        graph = createGraph('d3');
        
        // ===== EVENT HANDLERS =====
        
        // Handle layout algorithm changes
        layoutSelect.addEventListener('change', function() {
            debug(`Changing layout to: ${this.value}`);
            
            // Recreate graph with new engine
            graph = createGraph(this.value);
        });
        
        // Toggle handlers for labels
        nodeLabelsCheckbox.addEventListener('change', function() {
            debug(`Node labels: ${this.checked}`);
            graph.refresh(); // Force redraw
        });
        
        linkLabelsCheckbox.addEventListener('change', function() {
            debug(`Link labels: ${this.checked}`);
            graph.refresh(); // Force redraw
        });
        
        // Button handlers
        zoomInButton.addEventListener('click', function() {
            debug('Zooming in');
            const currentZoom = graph.zoom();
            graph.zoom(currentZoom * 1.5);
        });
        
        zoomOutButton.addEventListener('click', function() {
            debug('Zooming out');
            const currentZoom = graph.zoom();
            graph.zoom(currentZoom / 1.5);
        });
        
        resetButton.addEventListener('click', function() {
            debug('Resetting view');
            graph.zoomToFit(400);
        });
        
        expandButton.addEventListener('click', expandGraph);
        
        contractButton.addEventListener('click', contractGraph);
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (graph) {
                graph.width(graphContainer.clientWidth);
                graph.height(graphContainer.clientHeight);
            }
        });
        
        // Initial setup
        debug('Graph initialization complete');
    }
</script>
{% endblock %}